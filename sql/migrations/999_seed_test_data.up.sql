

INSERT INTO
  modules (title, course_id)
VALUES
  ('Переменные и базовые типы', 1),
  ('Ветвление и Циклы', 1),
  ('Функции', 1),
  ('Пределы и Непрерывность', 2),
  ('Производная: Определения и правила', 2),
  ('Переменные и базовые типы', 4),
  ('Ветвление и Циклы', 4),
  ('Функции', 4);

insert into
  assignments (
    module_id,
    course_id,
    title,
    "description",
    content,
    assignment_type_id
  )
VALUES
  (
    1,
    1,
    'Типы Данных',
    '',
    '{"content":"<h1>Лекция: Типы данных в Go</h1><p>Язык программирования C++ поддерживает различные типы данных, которые используются для хранения различных видов значений. Вот основные типы данных в C++:</p><ul><li><strong>int:</strong> Целочисленный тип данных, который может хранить целые числа.</li><li><strong>float:</strong> Тип данных с плавающей точкой для хранения чисел с плавающей запятой одинарной точности.</li><li><strong>double:</strong> Тип данных с плавающей точкой для хранения чисел с плавающей запятой двойной точности.</li><li><strong>char:</strong> Тип данных для хранения одного символа.</li><li><strong>bool:</strong> Логический тип данных, который может хранить только значения true или false.</li></ul><p>Кроме того, в C++ можно создавать пользовательские типы данных с помощью структур и классов.</p><p>Знание различных типов данных в C++ важно для правильного объявления переменных и выполнения операций в программе.</p><p>Это основы типов данных в C++, которые вы будете использовать при изучении и разработке программ на этом языке.</p>"}',
    1
  ),
  (
    2,
    1,
    'Ветвление и Циклы',
    '',
    '{"content":"<h1>Лекция: Ветвления и Циклы в Go</h1><p>В программировании ветвления и циклы используются для управления потоком выполнения программы. В языке C++ существует несколько основных конструкций ветвления и циклов:</p><ul><li><strong>if-else:</strong> Конструкция, которая позволяет выполнить блок кода, если условие истинно, и другой блок кода, если условие ложно.</li><li><strong>switch:</strong> Конструкция, которая позволяет выбрать один из множества вариантов выполнения кода в зависимости от значения выражения.</li><li><strong>for:</strong> Цикл, который выполняет блок кода заданное количество раз.</li><li><strong>while:</strong> Цикл, который выполняет блок кода, пока условие истинно.</li><li><strong>do-while:</strong> Цикл, который выполняет блок кода, а затем проверяет условие, чтобы решить, нужно ли продолжить выполнение цикла.</li></ul><p>Эти конструкции позволяют программистам создавать более гибкие и мощные программы, которые могут адаптироваться к различным условиям и вводным данным.</p><p>Понимание ветвлений и циклов в C++ является ключевым навыком для эффективного программирования на этом языке.</p>"}',
    1
  ),
  (
    3,
    1,
    'Функции',
    '',
    '{"content":"<h1>Лекция: Функции в Go</h1><p>Функции в языке программирования C++ позволяют группировать блоки кода для выполнения конкретной задачи. Вот основные понятия и принципы функций в C++:</p><ul><li><strong>Объявление функции:</strong> Функция объявляется с указанием её типа возвращаемого значения, имени и параметров, если они есть. Например: <code>int add(int a, int b);</code></li><li><strong>Определение функции:</strong> Функция определяется с использованием ключевого слова <code>return</code> для возврата значения. Например: <code>int add(int a, int b) { return a + b; }</code></li><li><strong>Вызов функции:</strong> Функция вызывается по её имени с передачей аргументов, если они необходимы. Например: <code>int sum = add(5, 3);</code></li><li><strong>Рекурсия:</strong> Возможность функции вызывать саму себя. Рекурсия часто используется для решения задач, которые могут быть разбиты на подзадачи того же типа.</li><li><strong>Перегрузка функций:</strong> Возможность определить несколько функций с одним и тем же именем, но с разными списками параметров. Это позволяет создавать более универсальные и гибкие функции.</li></ul><p>Функции в C++ играют ключевую роль в создании модульных, многоразовых и понятных программ. Они позволяют разбивать сложные задачи на более простые компоненты и повторно использовать код.</p>"}',
    1
  ),
  (
    4,
    2,
    'Непрерывность',
    '',
    '{"content":"<h1>Непрерывность функций</h1><h2>Определение непрерывности</h2><p>Функция f(x) непрерывна в точке c, если для любого числа ε > 0 найдется число δ > 0 такое, что для всех x из интервала (c - δ, c + δ) выполняется неравенство |f(x) - f(c)| < ε.</p><h2>Типы непрерывности</h2><ul><li><strong>Непрерывность на отрезке:</strong> Функция непрерывна на отрезке [a, b], если она непрерывна в каждой точке этого отрезка.</li><li><strong>Непрерывность слева и справа:</strong> Функция непрерывна слева в точке c, если предел функции существует и равен f(c); непрерывна справа, если предел существует и равен f(c).</li><li><strong>Непрерывность на интервале:</strong> Функция непрерывна на интервале (a, b), если она непрерывна в каждой точке этого интервала.</li></ul><h2>Примеры непрерывных функций</h2><p>Примерами непрерывных функций являются полиномы, тригонометрические функции (синус, косинус), экспоненциальные функции и т. д.</p><h2>Теоремы о непрерывности</h2><ol><li><strong>Теорема о непрерывности композиции:</strong> Если функция f(x) непрерывна в точке c, а функция g(x) непрерывна в точке f(c), то композиция g(f(x)) также непрерывна в точке c.</li><li><strong>Теорема о непрерывности на отрезке:</strong> Если функция f(x) непрерывна на отрезке [a, b], то она ограничена на этом отрезке и принимает наибольшее и наименьшее значения.</li></ol><p>Это лишь краткое введение в тему непрерывности функций. Более подробное изучение требует рассмотрения различных типов функций и более сложных теорем.</p>"}',
    1
  ),
  (
    1,
    1,
    'Summator',
    '',
    '{
        "content": {
            "language": "go",
            "code_test": "package main\n\nimport \"testing\"\n\n// sumator adds two integers and returns the result\n// TestSumator tests the sumator function\nfunc TestSumator(t *testing.T) {\n    tests := []struct {\n        i1, i2, expected int\n    }{\n        {1, 2, 3},\n        {-1, -1, -2},\n        {0, 0, 0},\n        {123, 456, 579},\n    }\n\n    for _, test := range tests {\n        result := sumator(test.i1, test.i2)\n        if result != test.expected {\n            t.Errorf(\"sumator(%d, %d) = %d; want %d\", test.i1, test.i2, result, test.expected)\n        }\n    }\n}",
            "quiz_question": ""
        }
    }'
);
