// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: course_material.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAssignmentById = `-- name: GetAssignmentById :one
  select 
    id,title,content::text,description,assignment_type_id 
  from assignments 
  where 
    id = $1 limit 1
`

type GetAssignmentByIdRow struct {
	ID               int64  `json:"id"`
	Title            string `json:"title"`
	Content          string `json:"content"`
	Description      string `json:"description"`
	AssignmentTypeID int64  `json:"assignment_type_id"`
}

func (q *Queries) GetAssignmentById(ctx context.Context, id int64) (GetAssignmentByIdRow, error) {
	row := q.db.QueryRow(ctx, getAssignmentById, id)
	var i GetAssignmentByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Description,
		&i.AssignmentTypeID,
	)
	return i, err
}

const getAssignments = `-- name: GetAssignments :many
SELECT DISTINCT
    a.id, a.module_id, a.course_id, a.title, a.description, a.content, a.days, a.assignment_type_id, a.created_at,
    m.title as module_name,
    COALESCE(pr.done IS NOT NULL, FALSE) AS read
FROM 
    assignments a
LEFT JOIN 
    progress pr ON a.id = pr.assignment_id AND pr.user_id = $2
left join
    modules m on a.module_id = m.id
WHERE  
    a.course_id = $1 
    AND a.assignment_type_id <> 1
`

type GetAssignmentsParams struct {
	CourseID int64 `json:"course_id"`
	UserID   int64 `json:"user_id"`
}

type GetAssignmentsRow struct {
	ID               int64       `json:"id"`
	ModuleID         int64       `json:"module_id"`
	CourseID         int64       `json:"course_id"`
	Title            string      `json:"title"`
	Description      string      `json:"description"`
	Content          []byte      `json:"content"`
	Days             pgtype.Int4 `json:"days"`
	AssignmentTypeID int64       `json:"assignment_type_id"`
	CreatedAt        pgtype.Date `json:"created_at"`
	ModuleName       pgtype.Text `json:"module_name"`
	Read             interface{} `json:"read"`
}

func (q *Queries) GetAssignments(ctx context.Context, arg GetAssignmentsParams) ([]GetAssignmentsRow, error) {
	rows, err := q.db.Query(ctx, getAssignments, arg.CourseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAssignmentsRow{}
	for rows.Next() {
		var i GetAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ModuleID,
			&i.CourseID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.Days,
			&i.AssignmentTypeID,
			&i.CreatedAt,
			&i.ModuleName,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseLectures = `-- name: GetCourseLectures :many
SELECT DISTINCT
    a.title,
    a.id AS assignment_id,
    COALESCE(pr.done IS NOT NULL, FALSE) AS read,
    m.title as module_name
FROM 
    courses c 
LEFT JOIN 
    modules m ON m.course_id = c.id
LEFT JOIN 
    assignments a ON a.module_id = m.id
LEFT JOIN 
    progress pr ON a.id = pr.assignment_id AND pr.user_id = $2
WHERE  
    c.id = $1
    AND a.id IS NOT NULL 
    AND a.assignment_type_id = 1
order by a.id asc
`

type GetCourseLecturesParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetCourseLecturesRow struct {
	Title        pgtype.Text `json:"title"`
	AssignmentID pgtype.Int8 `json:"assignment_id"`
	Read         interface{} `json:"read"`
	ModuleName   pgtype.Text `json:"module_name"`
}

func (q *Queries) GetCourseLectures(ctx context.Context, arg GetCourseLecturesParams) ([]GetCourseLecturesRow, error) {
	rows, err := q.db.Query(ctx, getCourseLectures, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCourseLecturesRow{}
	for rows.Next() {
		var i GetCourseLecturesRow
		if err := rows.Scan(
			&i.Title,
			&i.AssignmentID,
			&i.Read,
			&i.ModuleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseLecturesByModuleId = `-- name: GetCourseLecturesByModuleId :many
  select 
    a.id, a.module_id, a.course_id, a.title, a.description, a.content, a.days, a.assignment_type_id, a.created_at 
  from assignments a 
  left join 
      modules m on m.id = $1
  where 
      a.assignment_type_id = 1
`

func (q *Queries) GetCourseLecturesByModuleId(ctx context.Context, id int64) ([]Assignment, error) {
	rows, err := q.db.Query(ctx, getCourseLecturesByModuleId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Assignment{}
	for rows.Next() {
		var i Assignment
		if err := rows.Scan(
			&i.ID,
			&i.ModuleID,
			&i.CourseID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.Days,
			&i.AssignmentTypeID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLectureContent = `-- name: GetLectureContent :one
  select 
    title, content::text 
  from assignments
  where
    assignments.id = $1
`

type GetLectureContentRow struct {
	Title   string `json:"title"`
	Content string `json:"content"`
}

func (q *Queries) GetLectureContent(ctx context.Context, id int64) (GetLectureContentRow, error) {
	row := q.db.QueryRow(ctx, getLectureContent, id)
	var i GetLectureContentRow
	err := row.Scan(&i.Title, &i.Content)
	return i, err
}

const newLecture = `-- name: NewLecture :exec
insert into assignments (module_id,course_id,title,description,content,assignment_type_id)
values ($1,$2,$3,$4,$5,1)
`

type NewLectureParams struct {
	ModuleID    int64  `json:"module_id"`
	CourseID    int64  `json:"course_id"`
	Title       string `json:"title"`
	Description string `json:"description"`
	Content     []byte `json:"content"`
}

func (q *Queries) NewLecture(ctx context.Context, arg NewLectureParams) error {
	_, err := q.db.Exec(ctx, newLecture,
		arg.ModuleID,
		arg.CourseID,
		arg.Title,
		arg.Description,
		arg.Content,
	)
	return err
}
